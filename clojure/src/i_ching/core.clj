(ns i-ching.core)

(defn gather-sticks
  "Counting off a bundle of sticks by fours. Returns 1,2,3 or 4 (4 when mod 4 would return 0)."
  [sticks]
  (let [sticks-mod (mod sticks 4)]
    (if (zero? sticks-mod) 4 sticks-mod)))

(defn split-sticks
  "Split the sticks into two groups and count them off by fours. Returns 4,5,8 or 9."
  [sticks]
  (let [left-min (+ 5 (int (rand 12))) ;; when we split, we hold onto a minimum number of sticks
        right-min (+ 5 (int (rand 12)))
        left (+ left-min (int (rand (- sticks left-min right-min))))
        ;;left (int (rand sticks))
        right (- sticks 1 left)]
    (+ 1 (gather-sticks left) (gather-sticks right))))

(defn yarrow-sticks
  "Divide the yarrow sticks and come up with a set of 3 values from splitting the sticks."
  ([]
   (yarrow-sticks '() 49))
  ([accum sticks]
   (if (= 3 (count accum))
     accum
     (let [split-count (split-sticks sticks)]
       (yarrow-sticks (conj accum split-count) (- sticks split-count))))))

(defn two-or-three
  "Return 3 or 2 for the values generated by yarrow sticks."
  [value]
  (case value
    4 3
    5 3
    8 2
    9 2
    (throw (IllegalArgumentException. (str value " is not a valid value for split-sticks")))))

(defn hexagram-line
  "Return the value (6,7,8 or 9) of a single hexagram line."
  []
  (reduce + (map two-or-three (yarrow-sticks))))

(defn yin-or-yang [value]
  "Return a pair of yin (0) or yang (1) for the value generated by hexagram line."
  (case value
    6 '(0 1)
    7 '(1 1)
    8 '(0 0)
    9 '(1 0)))

(defn hexagram
  "Return a pair of sequences, the primary and related hexagrams. 
  Each sequence is six zeroes (yin) or ones (yang)."
  []
  (->> (repeatedly 6 hexagram-line)
       (map yin-or-yang)
       (apply map vector)))

(defn changing-lines
  "Return the zero-based indexes of the changing lines between a pair of hexagrams"
  [hexagrams]
  (->> hexagrams
       (apply interleave)
       (partition 2)
       (map-indexed (fn [idx item] (if (apply distinct? item) idx)))
       (remove nil?)))


